---
layout: slides
---

## What problems are we trying to solve?

- No formal training
  - "I don't know what I don't know"
- Low signal-to-noise ratio
  - "What, you've never read *Secrets of the Ninja DevOps Masters*?"

---

## Is software engineering?

- "The use of the scientific method to design novel things"
  - So…no
- Term was [invented in the late 1960s](https://www.youtube.com/watch?v=RhdlBHHimeM) in an attempt to push programming in a particular direction
- Analogies often betray a lack of understanding of how engineering really works

---

## What we know

- Steady growth of empirical studies over 30 years
  - Fueled in part by data from open source projects
- Many studies are small, and not all are well done
- But we can refute some myths and reveal new insights

---

## Are some languages better than others?

<cite>Stefik2013</cite>: "An Empirical Investigation into Programming Language Syntax"

- Measured how easily novices could read:
  - Perl
  - Quorum: the language their team is building
  - Randomo: syntax "designed" by rolling Dungeons & Dragons dice

---

## Are some languages better than others?

- Perl is as hard for novices to learn as a language with a randomly-designed syntax

---

## Are some languages better than others?

- Second study
  - More subjects
  - Multiple assessment strategies
- Languages in the C family are as hard for novices to learn to read as a randomly-designed language
- Ruby and Python are significantly easier
- Quorum is easier still

---

## Nobody knows anything

<cite>Altadmri2015</cite>: "37 Million Compilations: Investigating Novice Programming Mistakes in Large-Scale Student Data"

- Ask educators for learners' most common mistakes
- Compare their answers to empirical data
- Weak consensus among educators
- Weak correlation with observations
- Educator experience had only weak impact on results

---

## Nobody knows anything

- Most common actual errors are:
  - Mis-matched parentheses (*not* confusing `=` with `==`)
  - Invoking methods with the wrong arguments
  - Reaching end of non-`void` method without `return`
- The three that take the most time to fix are:
  - Confusing  short-circuit logical and bitwise operators
  - Using `==` instead of `.equals` to compare strings
  - Ignoring the return value from a non-void method

---

## Test-driven development

<cite>Shull2010</cite>: "How Effective is Test-Driven Development?"

> …evidence from controlled experiments suggests an
> improvement in productivity when [TDD](g#tdd) is used.
> However…pilot studies provide mixed evidence, some in
> favor of and others against TDD. In the industrial
> studies…evidence suggests that TDD yields worse
> productivity. Even when considering only the more rigorous
> studies…the evidence is equally split for and against a
> positive effect.

---

## Test-driven development

<cite>Fucci2016</cite>: "An External Replication on the Effects of Test-Driven Development Using a Multi-Site Blind Analysis Approach"

- Replication study, 39 professionals, real projects
- No significant difference between test-first and test-last development
- "The claimed benefits of TDD may…rather [be] due to the fact that [it] encourages fine-grained steady steps that improve focus and flow."

---

## Test-driven development

<cite>Fucci2016</cite>: "An External Replication on the Effects of Test-Driven Development Using a Multi-Site Blind Analysis Approach"

> I practice TDD…and it works great. We don't need to prove that it works anymore.

---

## Check your error handling

<cite>Yuan2014</cite>: "Simple Testing Can Prevent Most Critical Failures: An Analysis of Production Failures in Distributed Data-Intensive Systems"

- 198 randomly selected, user-reported failures on Cassandra, Hadoop MapReduce, etc.
- Majority of catastrophic failures could easily have been prevented by performing simple testing on error handling code

---

## Check your error handling

<cite>Nakshatri2016</cite>: "Analysis of Exception Handling Patterns in Java Projects: An Empirical Study"

- Most common `catch` block logs the error rather than trying to recover from it
- Next most common does nothing at all (20% of cases)
  - Or converts the checked exception into an unchecked one so it can be ignored.
- Most programmers catch generic exceptions rather than specific subclasses
  - So their error-handling is generic rather than specific

---

## "Open"

<cite>Steinmacher2015</cite>: "Social Barriers Faced by Newcomers Placing Their First Contribution in Open Source Software Projects"

- Identify 58 potential barriers
- What matters most?
  1. How easy it is to get set up to make a contribution
  1. How easy it is to find a task to start with
- Other work has also identified "how warmly first contribution was received"

---

## There is no "geek gene"

<cite>Patitsas2016</cite>: "Computer Science Grades Are Not Bimodal"

- The "geek gene" is computing's most enduring and damaging myth
- In fact, only 5.8% of course grade distributions at a large university were actually multi-modal
- But CS faculty are more likely to see distributions as bimodal if they think they're from a CS class
- Even *more* likely if they believe some students are innately predisposed to do well in CS

---

## Productivity

- <cite>Prechelt2000</cite> programmers implement the same thing in the language of their choice
- How long did it take?

{% include figure src="./productivity.svg" alt="Programmer productivity measures from Prechelt" %}

---

## Productivity

- Shortest and longest times were 0.6 and 63 hours
  - Ratio is 150X (!)
- But people used 7 different languages
- If we only look at Java, times are 3.8 vs. 63 hours (17X)
- But comparing best and worst exaggerates differences
- 90th percentile vs. 50th gives 3.7X

---

## Productivity

<cite>Begel2014</cite>: "Analyze This! 145 Questions for Data Scientists in Software Engineering"

- Ask a bunch of developers to propose questions, then ask another bunch to rate them
- Developers want to know how people actually use their products
- They *don't* want assessments of individual performance
  - Because they're afraid such measures will be weaponized

---

## Productivity

<cite>Sedano2017</cite>: "Software Development Waste"

- Building the wrong feature or product
- Mismanaging the backlog
- Rework
- Unnecessarily complex solutions
- Extraneous cognitive load
- Psychological distress
- Waiting/multitasking
- Knowledge loss
- Ineffective communication

---

## A few random results

- Rapid releases can mean fixes take *longer* to get integrated (<cite>AlencarDaCosta2017</cite>)
- Traditional release cycles prioritize integration of backlog issues
- Rapid release cycles prioritize integration of freshly-fixed issues

---

## A few random results

- Original authors fix their own simple bugs much faster than other people (<cite>Zhu2021</cite>)
- But are more likely to fix or change other things at the same time

<div class="flex-row">
  <div class="flex-col">
    <img src="bug-fix-time.png" alt="Bug fix time" width="80%" />
  </div>
  <div class="flex-col">
    <img src="bug-fix-churn.png" alt="Bug fix churn" width="80%" />
  </div>
</div>

---

## A few random results

<cite>Xu2015</cite>: developers create a lot more configuration options than people use

- Only 6.1%-16.7% of parameters set by majority of users
- 54.1% of parameters are rarely set by *any* user
- Only 1.8%-7.8% of parameters are configured by more than 90% of users
- Up to 48.5% of config issues are about difficulty finding or setting parameters
- Up to 53.3% of config errors are due to users' staying with default values incorrectly
- Searching user manuals by keywords is not efficient to help users identify parameters

---

## A few random results

- Most developers understand the implications of a single license
- But do *not* understand the interactions between two or more licenses <cite>Almeida2017</cite>

---

## A few random results

- <cite>Abad2018</cite>: programmers think external interruptions are more disruptive than internal ones, but the reverse is actually true
- <cite>Zieris2020</cite>: Major benefit of pair programming is transfer of problem-specific knowledge
- <cite>McIntosh2021</cite>: Only 7% of hackathon projects have any activity after 6 months
- <cite>Wessel2020</cite>: Use of code review bots increases the number of merged PRs but decreases inter-programmer communication
- <cite>Palomba2021</cite>: Community smells lead to code smells

---

class: exercise

## How do you assess productivity?

1. How do you tell when one person on your team is more or less productive than another?
1. How do you adjust for (lack of) self-confidence in team members' reporting?

---

class: exercise

## How do you handle errors?

1. How are errors caught and reported in your code?
1. How hard is it for a newcomer to go from an error message to the source of the problem?
